[Mark Gibson](https://github.com/jollytoad) (2015-11-05)

# Bloglet Part 6

## Processing

Now we've loaded the raw markdown, it needs converting into html and rendering.
The idea in fluxlet is to do the processing in a calculation, push it into the
state and keep the rendering side-effect simple.

### Calculation

Eventually we'd like to support processing of other formats, and we don't want
to attempt markdown processing on anything that isn't markdown, so we'll have
a condition on the calculation to check this...

```js
const processMarkdown = {
  when: contentIs(['text/x-markdown'], ['text/plain', '.md']),

  then: update('content.html', (x, {content:{raw}}) =>
          showdownConverter.makeHtml(raw))
}
```

*contentIs* takes a list of criteria, which defines the possible content types
and optionally the file extension the processor can handle. It returns a
predicate that checks if the state is awaiting html and that we have some raw
content that is ready for conversion.

```js
const contentIs = (...criteria) =>

  // create the predicate
  ({ place, content: { raw, type, html }}) =>

    // check that we are still awaiting html,
    // and we have some raw content and type of that content
    !html && raw && type &&

    // scan through the criteria list for a match against the type and
    // optionally the file extension
    criteria.some(
      ([ mime, ext ]) =>
        type.startsWith(mime) && (!ext || place.endsWith(ext))
    )
```

We also need a markdown processor ready for use by the processor...

```js
const showdownConverter = new showdown.Converter()
```

## Rendering

At this stage we'll be keeping rendering simple, and using our old friend
jQuery to locate and insert our processed content.

Fluxlet itself is completely agnostic to the rendering, and you could choose to
use React or some other virtual DOM implementation.

### Side effect

Our rendering side-effect will take any html generated by the processing
calculations and shove into the DOM with a simple innerHTML assignment.

We'll also update the URL at this stage to support the usual browser navigation.

```js
const renderContent = {
  when: (state, prev) => state.content.html && state.content.html !== prev.content.html,

  then: ({content:{html}, place}) => {

    $("#main").html(html)

    // Grab the page title from the first heading
    const title = $("#main h1:first").text()

    // Update the URL
    history.pushState({}, title, '?'+place)
  }
}
```

### Registration

As usual, this new components need registering with the fluxlet...

```js
export function setup() {
  fluxlet("bloglet")
    .state(initialState)
    .actions({
      route,
      loaded
    })
    .calculations({
      home,
      processMarkdown  // <- new calculation
    })
    .sideEffects({
      load,
      renderContent    // <- new side-effect
    })
    .init(
      bindReady
    )
}
```

And that's it, we now have a functional application. Although there are many
more improvements that could be made, this gives us a good starting point.
